#!/usr/bin/perl

#### STRICTURES ####
use strict;
use warnings;
use feature qw( state say );

#### NEADWERX MODULES ####
use Carp;
use Readonly;
use Perl6::Export::Attrs;
use English qw( -no_match_vars );
use Fatal qw( open );
use Params::Validate qw( :all );

#### INTERNAL MODULES ####

#### CPAN MODULES ####
use Data::Dumper;
use Getopt::Long;
use REST::Client;
use JSON::Tiny qw( decode_json encode_json to_json );

#### READONLYS ####
Readonly my $FALSE              => 0;
Readonly my $TRUE               => 1;
Readonly my $DEFAULT_SUPERVISOR => 'drue';

# List of users at neadwerx => and their supervisor
my $USERS = {};

$USERS->{'nickolas'}->{'nickolas'} = 0;

use vars qw( $USER_NAME );

#### PRIVATE SUBROUTINES ####

# Prints the message and usage information.
# Params   : message (string)
# Comments : Exits with status code -1
sub _usage($)
{
    my ( $message ) = validate_pos( @_, { type => SCALAR, default => '' } );

    say "$message";
    say "Usage: $0 <NAME> [--default]";
    say "Attempts to return the email address of the given <NAME>'s supervisor at Nead Werx.";

    exit -1;
}

# Parses the command line for arguments and options.
sub _parse_command_line
{
    my $return_default = $FALSE;

    GetOptions(
        '<>'      => \&_parse_arg,
        'default' => \$return_default
    ) or _usage( 'Unable to parse command line arguments.' );

    if( $return_default == $TRUE )
    {
        print $DEFAULT_SUPERVISOR . "\@merchlogix.com\n";
        exit 0;
    }

    unless( $USER_NAME )
    {
        _usage( 'Missing required name.' );
    }

    return;
}

# Handler for the user name from the command line.
# Params   : arg (getopts)
sub _parse_arg($)
{
    my ( $arg ) = validate_pos( @_, 1 );

    state $num_args_parsed = 1;

    if( $num_args_parsed >= 2 )
    {
        _usage( 'Only one name at a time.' );
    }

    $USER_NAME = $arg;

    return;
}

# Finds the given supervisor for a string input.
# This method attempts to first normalize the name.
# Returns  : supervisor (string)
# Params   : name (string)
sub _find_supervisor_old($)
{
    my ( $name ) = validate_pos( @_, { type => SCALAR } );

    # remove any last names
    ( $name ) = split( /\s/, $name );

    # remove any email suffix
    ( $name ) = split( /@/, $name );

    # lowercase the name
    $name = lc( $name );

    # trim the whitespace from the name
    $name =~ s/^\s+|\s+$//g;

    if( defined $USERS->{$name} )
    {
        my $direct_supervisor_rank = 10000;
        my $direct_supervisor      = '';
        foreach my $supervisor ( keys %{ $USERS->{$name} } )
        {
            if ( $USERS->{$name}->{$supervisor} < $direct_supervisor_rank )
            {
                $direct_supervisor = $supervisor;
                $direct_supervisor_rank = $USERS->{$name}->{$supervisor};
            }
        }
        return $direct_supervisor;
    }

    return $DEFAULT_SUPERVISOR;
}

# Finds the given supervisor for a string input.
# This method attempts to first normalize the name.
# Returns  : supervisor (string)
# Params   : name (string)
sub _find_supervisor_new($)
{
    my ( $name ) = validate_pos( @_, { type => SCALAR } );
    my $client = REST::Client->new
    (
        {
            host => "https:\/\/xpm.neadwerx.com\/api\/v1",
        }
    );
    $client->addHeader('Authorization','Bearer fa8e04297906ca779c50b82cc86afee9');
    $client->GET("\/supervisors");
    my $response =  decode_json( $client->responseContent() );
    my $nickolas;
    foreach my $supervisor ( @{ $response->{data} } )
    {
        $supervisor = $supervisor->{attributes};
        my $rank = @{ $supervisor->{subordinates}->{data} };
        foreach my $subordinate ( @{ $supervisor->{subordinates}->{data} } )
        {
            $subordinate = $subordinate->{attributes};
            $USERS->{ lc( $subordinate->{first_name} ) }->{ lc( $supervisor->{first_name} ) } = $rank;
        }
    }
    return _find_supervisor_old( $name );
}

#### MAIN PROGRAM ####
_parse_command_line();

my $supervisor = _find_supervisor_new( $USER_NAME );

print( $supervisor . "\@merchlogix.com\n" );

exit 0;

__END__

=pod

=head1 NAME

get_supervisor_email.pl - A script to determine the supervisor to email on a Nead Werx machine.

=head1 SYNOPSIS

    get_supervisor_email harrison
    get_supervisor_email 'kirk@merchlogix.com'
    get_supervisor_email 'Harrison Katz'
    get_supervisor_email --default

=head1 DESCRIPTION

This script is used to get the supervisor email of a given
user here at Nead Werx. The name given to the script are
first attempted to be normalized from spaces, cases, email
addresses, and first/last names. If a name is not found the
supervisor will be the default.

=head1 AUTHOR

Harrison <harrison@merchlogix.com>

=cut
