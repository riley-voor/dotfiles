#!/bin/bash

# INPUTS
commit_message_file="$1"

source .git/hooks/lib.sh

exit_if_commit_hooks_should_not_run

# MAIN PROGRAM
echo "-COMMIT-MSG HOOKS---------------------------------------------------------------------------------"
color_echo yellow "Formatting commit message..."

# delete all lines that are start as comments
perl -p -i -e 's/^#.*$//g' $commit_message_file

# delete duplicate lines (like newlines)
tmp_file="/tmp/tmp_msg.$$.txt"
cat -s $commit_message_file | fmt -s -u -w 110 > $tmp_file && mv $tmp_file $commit_message_file && rm -f $tmp_file

# delete leading empty lines
sed -i '/./,$!d' $commit_message_file

# ensure that the second line of the commit message is a blank line
line_count=`cat $commit_message_file | wc -l`
second_line=`head -2 $commit_message_file | tail -1`
if [[ $line_count -gt 1 ]] && [[ -n "$second_line" ]] ; then
    # add a blank line between the subject and the body
    sed -i '2i\\' $commit_message_file
fi

# remove the last line of the file if it is a newline
perl -p -i -e 'chomp if eof' $commit_message_file

# save a copy of this formatted commit message
cp -f $commit_message_file "$GIT_DIR/.saved_commit_message"

# spell check the commit message
#   1. cat the commit message
#   2. replace leading or trailing single quotes (these confuse hunspell) with a space
#   3. split camelCaseWords
#   4. split AcronymWORDS like ThdcaIMS
#   5. check this with hunspell and the special neadwerx dictionary files (/usr/share/myspell/neadwerx.(dic|aff))
#   6. filter only the & near-misses and # missing words
#spellcheck=$(cat $commit_message_file | \
#    perl -pe 's/'"'"'(\W)/ $1/g;s/(\W)'"'"'/$1 /g;s/^'"'"'/ /;s/'"'"'$/ /;' | \
#    sed -E 's/([A-Z][a-z])/ \1/g' | \
#    sed -E 's/([a-z]+)([A-Z]+)/\1 \2/g' | \
#    hunspell -d neadwerx -a | \
#    grep -P '^[&#]'
#)

# now, spellcheck contains a list of lines with 1 word each in the format
#   <&|#> <misspelled word> <number of potential misses> <offset (incorrect)>: <word misses>
#
# '&' means that the misspelled word has potential matches after the colon
# '#' means the word is completely missing from the dictionary

# if the spellcheck found misspellings, then assist in fixing these
# if [[ -n "$spellcheck" ]] ; then
#     # create a formatted commit message with the misspellings highlighted
# 
#     # start with the previous commit message
#     highlighted_commit_message=`cat $commit_message_file`
#     while read line ; do
#         # replace the misspelling in the commit message with color echo chars around it
#         misspelling=`echo $line | awk '{print $2}'`
#         highlighted_commit_message=`echo "$highlighted_commit_message" | perl -pe "s{(\\b|_|(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])))\\Q$misspelling\\E(\\b|_|(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])))}{\\1\\033[1;31m$misspelling\\033[0m\\2}g"`
#     done <<< "$spellcheck"
# 
#     # print out the commit message with the misspellings highlighted
#     color_echo yellow "Your commit message contains spelling errors, please fix these to continue..."
#     echo ""
#     echo -e "$highlighted_commit_message"
#     echo ""
# 
#     # for each misspelling, help the user fix the word
#     while read -u 3 line ; do
#         misspelling=`echo $line | awk '{print $2}'`
#         misspelling_type=`echo $line | awk '{print $1}'`
# 
#         # if the misspelled word is a near-miss
#         if [[ "$misspelling_type" == "&" ]] ; then
#             # get potential words for the misspelling
#             potential_words=`echo $line | cut -d: -f2-`
# 
#             # no space because hunspell adds one after the ":" on each line
#             did_you_mean="(did you mean?$potential_words)"
#         fi
# 
#         # request a proper spelling from the user
#         echo -e "\\033[1;33mMisspelled:\\033[0m \\033[1;31m$misspelling\\033[0m $did_you_mean"
#         q "Proper spelling:"
#         if [[ -z "$ANSWER" ]] ; then
#             # empty spelling means the user wants to keep the misspelling as-is
#             ANSWER="$misspelling"
#         fi
# 
#         # replace the misspelling with the proper spelling in the real commit message file
#         perl -p -i -e "s{(\\b|_|(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])))\\Q$misspelling\\E(\\b|_|(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])))}{\\1${ANSWER}\\2}g" $commit_message_file
#     done 3<<< "$spellcheck"
# 
#     # spellchecking and fixing is finished, so
#     # save a copy of this new formatted commit message
#     cp -f $commit_message_file "$GIT_DIR/.saved_commit_message"
# 
#     # check if there are still misspellings
#     respellcheck=$(cat $commit_message_file | \
#         perl -pe 's/'"'"'(\W)/ $1/g;s/(\W)'"'"'/$1 /g;s/^'"'"'/ /;s/'"'"'$/ /;' | \
#         sed -E 's/([A-Z][a-z])/ \1/g' | \
#         sed -E 's/([a-z]+)([A-Z]+)/\1 \2/g' | \
#         hunspell -d neadwerx -a | \
#         grep -P '^[&#]'
#     )
# 
#     # if there are still spelling mistakes
#     if [[ -n "$respellcheck" ]] ; then
#         color_echo red "Your commit message still contains spelling mistakes!"
# 
#         # highlight the spelling mistakes
#         highlighted_commit_message=`cat $commit_message_file`
#         while read line ; do
#             # replace the misspelling in the commit message with color echo chars around it
#             misspelling=`echo $line | awk '{print $2}'`
#             highlighted_commit_message=`echo "$highlighted_commit_message" | perl -pe "s{(\\b|_|(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])))\\Q$misspelling\\E(\\b|_|(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])))}{\\1\\033[1;31m$misspelling\\033[0m\\2}g"`
#         done <<< "$respellcheck"
# 
#         # print out the highlighted commit message
#         echo ""
#         echo -e "$highlighted_commit_message"
#         echo ""
# 
#         # ask the user if they want to commit anyways
#         ask "Do you wish to commit with these spelling mistakes?"
#         if [[ $ANSWER == y ]] ; then
#             # print brief message about spellchecking and the neadwerx dictionary
#             echo ""
#             color_echo purple "If you wish to add any of these words to the Nead Werx dictionary file, then"
#             color_echo purple "please email Kirk Bauer <kirk@merchlogix.com> with the word to add."
#             color_echo purple "If it's an acronym, please describe what it means and how it's used. Thanks!"
#             echo ""
#         else
#             abort_commit
#         fi
#     fi
# fi

# verify that the commit message is what the user wants
color_echo green "Here is your formatted commit message:"

# print the message
echo ""
cat $commit_message_file
echo ""

ask "Do you wish to use this commit message?"
if [[ "$ANSWER" != "y" ]] ; then
    abort_commit
fi

# continue
color_echo yellow "Checking commit message..."

# save for later
commit_message=`cat $commit_message_file`
branch=`get_current_branch`

# verify the first line is split into <ticket> <subject>
first_line=`head -1 $commit_message_file`
ticket=`echo $first_line | cut -d' ' -f1`
subject=`echo $first_line | cut -d' ' -f2-`

# check if ticket matches JIRA format
declare -a ticket_formats=(
   'PROD-[0-9]+'
   'TEST-[0-9]+'
   'THDIC-[0-9]+'
   'XERP-[0-9]+'
   'SCOR-[0-9]+'
   'SS-[0-9]+'
   'DVO-[0-9]+'
)

matches_regex_element "$ticket" "${ticket_formats[@]}"
if [[ $? != 0 ]] ; then
    color_echo red "Ticket is missing, or does not match a valid format!"
    color_echo yellow "Found ticket: $ticket"
    exit 1
fi

# check if branch and ticket match in JIRA
issue_branch=`/usr/bin/perl /etc/profile.d/git/check_ticket_and_branch.pl -t="$ticket" -b="$branch"`
[[ $? == 0 ]] || {
    echo ""
    color_echo red "Current branch and JIRA issue ($ticket) branch do not match!"
    color_echo yellow "$ticket branch: $issue_branch"
    color_echo yellow "Current branch: $branch"
    echo "Hint: Check your JIRA Ticket to ensure it has the correct branch."
    echo "      [see: https://neadwerx.atlassian.net/browse/$ticket]"
    exit 1
}

# all done!
exit 0
