#!/bin/bash

source $GIT_DIR/hooks/lib.sh
source $GIT_DIR/hooks/commit_hook_lib.sh

# This script parses the docblocks for any api files that have been touched,
# it ensures that a description is present and valid for the following items:
#     - Resources
#     - Routes
#     - Traits
#     - Required Inputs
#
# Each description should be a full, valid sentence that accurately describes
# what, when, and why an item should be used or set.
#
# It also checks various lines in the docblocks to make sure that they are correct.

# MAIN PROGRAM

get_files_to_check files '(api/controllers|api/traits)' 'AMCR'

# if there are no files, then don't worry about it :)
if [ -z "$files" ] ; then
    exit 0
fi

hook_set_changes_hash "$files"
skip_hook_if_record_matches

# go through each file and parse them line by line
# use a state machine to parse docblocks
# assume that every docblock needs an @desc line
# the states can be the following:
#     - searching                       :: looking for a docblock
#     - docblock                        :: inside a docblock
#     - expecting_array_item_definition :: the first line after an array input
#                                          should be the array item definition.
#     - expecting_definition            :: the first line after a docblock
#                                          should be a function or class definition
#     - skip_file                       :: skips the rest of the file
#
# if I run into a class or function definition without seeing a docblock
# directly above, then assume that it is missing a docblock and therefore
# an error
for file in $files ; do
    # reset the state to searching and object to 0
    state='searching'
    object_has_desc=0

    # read the file line by line
    line_number=-1
    while read line ; do
    line_number=$((line_number + 1))
    # save on whitespace, no indent
    case $state in
        searching)
            # test if line is a class definition
            regex="class[[:space:]]+[[:alpha:]]+(Controller|Trait)"
            if [[ "$line" =~ $regex ]] ; then
                hook_error "$(
                    color_echo red "Missing docblock for class definition in file '$file'"
                    color_echo yellow "Near line ($line_number): $line"
                )"
                state='skip_file'
                continue
            fi

            # test if line is a function definition
            regex="function[[:space:]]+[[:alpha:]]+\("
            if [[ "$line" =~ $regex ]] ; then
                hook_error "$(
                    color_echo red "Missing docblock for function definition in file '$file'"
                    color_echo yellow "Near line ($line_number): $line"
                )"
                state='skip_file'
                continue
            fi

            # test if line is the start of a docblock
            regex="/\*\*"
            if [[ "$line" =~ $regex ]] ; then
                state='docblock'

                # reset counter b/c starting new object
                object_has_desc=0
                continue
            fi

            ;;
        docblock)
            # test if line is the end of a docblock
            regex="\*/"
            if [[ "$line" =~ $regex ]] ; then
                state='expecting_definition'
                continue
            fi

            # test if line is @desc
            regex="\* @desc"
            if [[ "$line" =~ $regex ]] ; then
                object_has_desc=1

                # check for valid description
                regex="\* @desc[[:space:]]*([[:space:]][[:upper:]][^_.]+\.)+$"
                if [[ ! "$line" =~ $regex ]] ; then
                    hook_error "$(
                        color_echo red "Improper description found in file '$file'"
                        color_echo yellow "Near line ($line_number): $line"
                        echo "Hint: Proper descriptions start with a capital letter, end with a period, and do not contain underscores."
                    )"
                    state='skip_file'
                    continue
                fi
            fi

            # test if line is a required input
            if echo "$line" | grep -q -P '\* @input\s+[\w_]+\s+[\W]*required' ; then
                # check for valid description
                regex="\* @input[[:space:]]+[[:print:]]+([[:space:]][[:upper:]][^_.]+\.)+$"
                if [[ ! "$line" =~ $regex ]] ; then
                    hook_error "$(
                        color_echo red "Improper or missing description for required input"
                        color_echo red "found in file '$file'"
                        color_echo yellow "Near line ($line_number): $line"
                        echo "Hint: Proper descriptions start with a capital letter, end with a period, and do not contain underscores."
                    )"
                    state='skip_file'
                    continue
                fi
            fi

            # test if line is an array
            regex="\* @input[[:space:]]+[[:alpha:]|]*array"
            if [[ "$line" =~ $regex ]] ; then
                # get the name of the array
                current_array_name=`echo "$line" | awk '{print $3}'`
                state="expecting_array_item_definition"
            fi
            ;;
        expecting_array_item_definition)
            # test if line matches the required array item format
            regex="\* @input[[:space:]]+$current_array_name\.\\\$"
            if [[ ! "$line" =~ $regex ]] ; then
                hook_error "$(
                    color_echo red "Missing required array item definition"
                    color_echo red "found in file '$file'"
                    color_echo yellow "Near line ($line_number): $line"
               )"
               state='skip_file'
               continue
            fi

            # if it made it here then the line was fine, move on to the docblock state
            state="docblock"
            ;;
        expecting_definition)
            # test if line is a definition
            regex="(class|function)"
            if [[ "$line" =~ $regex ]] ; then
                # this is checked here so the near line has useful meaning
                # check if a description was not found for the object
                if [[ $object_has_desc == 0 ]] ; then
                    hook_error "$(
                        color_echo red "Missing description for docblock in file '$file'"
                        color_echo yellow "Near line ($line_number): $line"
                    )"
                    state='skip_file'
                    continue
                fi

                state='searching'
                continue
            fi

            # error if nothing matched
            hook_error "$(
                color_echo red "Expected class or function definition after docblock in file '$file'"
                color_echo yellow "Near line ($line_number): $line"
            )"
            state='skip_file'
            continue
            ;;
        skip_file)
            continue
            ;;
        *)
            color_echo red "Show this to kirk@merchlogix.com"
            color_echo red "INVALID STATE: $state"
            color_echo yellow "File: $file"
            color_echo yellow "Near line ($line_number): $line"
            hook_fail
            ;;
    esac
    done < $file
done

hook_exit
