#!/bin/bash

source $GIT_DIR/hooks/lib.sh
source $GIT_DIR/hooks/commit_hook_lib.sh

# This script checks that sql files are checked into the right directory,
# namely sql/*/here, not in sql itself.
# It also checks that the files checked in follow the following naming convention:
# <VALID_TICKET>.<CUSTOMER_ID>.<DESCRIPTION>.sql
#
# Also no *.sql files may have 'alter', 'create', or 'drop' in their contents unless
# they have a customer value of 'schema'
#
# All "create table <table_name>" commands must have a corresponding "comment on table <table_name> is 'Comment';"
#
# All alters must have a "--description: " comment somewhere in the file
#
# Alters must not have a call to get_translation without specifying the locale
#
# Alters must not have calls to `fn_label_last_transaction()` but instead should be `fn_label_transaction()`

# MAIN PROGRAM

get_files_to_check files '^sql/.*sql' 'AMR'

# if there are no files, then don't worry about it :)
if [ -z "$files" ] ; then
    exit 0
fi

hook_set_changes_hash "$files"
skip_hook_if_record_matches

declare -a ignore_dirs=(
    '*demo_data*'
    '*functions*'
    '*views*'
)

declare -a valid_sql_dirs=(
    '*versioned*'
    '*unversioned*'
    '*draft*'
)

valid_customer_ids=`get_customer_data --list | jq -r 'join( " " )'`

declare -a additional_customer_ids=(
    'schema'
    'special'
)

declare -a valid_tickets=(
   'PROD-[0-9]+'
   'TEST-[0-9]+'
   'THDIC-[0-9]+'
   'XERP-[0-9]+'
   'SCOR-[0-9]+'
   'SS-[0-9]+'
)

for file in $files ; do
    # split my file into checkable parts
    directory_name=`dirname "$file"`
    file_name=`basename "$file"`

    matches_glob_element "$directory_name" "${ignore_dirs[@]}"
    if [[ $? == 0 ]] ; then
        # skip special directories
        continue
    fi

    matches_glob_element "$directory_name" "${valid_sql_dirs[@]}"
    if [[ $? != 0 ]] ; then
        # incorrect directory
        hook_error "$(
            color_echo red "Committing an alter to an incorrect directory is not allowed!"
            color_echo yellow "Offending file: $file"
            echo "Hint: The following are valid locations:"
            echo "      sql/versioned/"
            echo "      sql/unversioned/"
            echo "      sql/draft/"
        )"
        continue
    fi

    # split file_name into array on '.'
    file_array=(${file_name//./ })

    ticket=(${file_array[0]})
    customer_id=(${file_array[1]})
    description=(${file_array[2]})
    extension=(${file_array[3]})

    matches_regex_element "$ticket" "${valid_tickets[@]}"
    if [[ $? != 0 ]] ; then
        # incorrect ticket in name
        hook_error "$(
            color_echo red "Alter name requires a valid ticket number as the first named part!"
            color_echo yellow "Offending file: $file"
        )"
        continue
    fi

    all_valid_schema_customers=( "${valid_customer_ids[@]}" "${additional_customer_ids[@]}" )
    matches_regex_element "$customer_id" ${all_valid_schema_customers[@]}
    if [[ $? != 0 ]] ; then
        # incorrect customer_id in name
        hook_error "$(
            color_echo red "Alter name requires a valid customer as the second named part!"
            color_echo yellow "Offending file: $file"
        )"
        continue
    fi

    # filename does not contain 'schema'
    if ! echo "$customer_id" | grep -q 'schema' ; then
        # grep file for restricted words
        if cat "$file" | grep -q -i -P '^\s*(?:alter|create(?!\s+temp)|drop)\s+[\w\s_();]+(?!--\s*BYPASS\s*DDL\s*CHECK)(?:--.*)?$' ; then
            # not allowed
            hook_error "$(
                color_echo red "Alter name requires 'schema' for schema modifications"
                color_echo yellow "Found 'alter', 'create', or 'drop' in file: $file"
                echo "Hint: Bypass with comment '-- BYPASS DDL CHECK' after the reserved word."
           )"
           continue
        fi
    fi

    # filename does contain 'special'
    if echo "$customer_id" | grep -q 'special' ; then
        # must contain --include: or --exclude: with valid customer_ids
        # on lines 1-3
        is_ok="0"
        old_ifs=$IFS
        IFS=$'\n'
        lines=`head -n 3 $file`
        for line in $lines ; do
            # if line matches include/exclude
            if echo "$line" | grep -P -q '\s*--(?:include|exclude):\s+' ; then
                # remove the include/exclude part and get the list of customers used
                customers_used=`echo "$line" | sed 's/--\(exclude\|include\)://' | tr -d ' \n' | tr ',' '\n'`

                # check each customer used to ensure it is a valid customer
                IFS=$old_ifs
                for customer in $customers_used ; do
                    matches_regex_element "$customer" $valid_customer_ids
                    if [[ $? != 0 ]] ; then
                        # incorrect customer in include/exclude
                        hook_error "$(
                            color_echo red "Invalid customer id '$customer' used in include/exclude!"
                            color_echo yellow "Offending file: $file"
                        )"
                        continue
                    fi
                done
                IFS=$'\n'

                # we found an include/exclude so we claim this alter
                # has valid special alter syntax
                is_ok="1"
            fi
        done
        IFS=$old_ifs

        # aka not ok
        if [[ "$is_ok" == "0" ]] ; then
            hook_error "$(
                color_echo red "Special alter syntax is missing from the top of the file!"
                color_echo yellow "Offending file: $file"
                echo "Hint: Must have one of --include: <customer...> or --exclude: <customer...> at the top of the alter."
            )"
            continue
        fi
    else
        # check alter for incorrect requires
        # only check non-special alters

        # get the customers from the alters that this file requires
        required_customers=`cat "$file" | grep -o -P '^--requires:\s+([\w\d._-]+?.sql)' | cut -d' ' -f2 | cut -d'.' -f2 | sort | uniq`

        # check to ensure the required customers are allowed
        for required_customer in $required_customers ; do
            if [[ "$required_customer" == "schema" ]] ; then
                # all alters are allowed to require schema alters
                continue
            fi

            # required_customer is not schema

            if [[ "$customer_id" == "schema" ]] ; then
                if [[ "$required_customer" == '*' ]] ; then
                    # Allow * for wildcard customer requirements in scehma alters (see DVO-891 & DVO-898)
                    continue
                fi

                # schema alter reqires non-schema
                hook_error "$(
                    color_echo red "Schema alters are not allowed to require non-schema alters"
                    color_echo yellow "Offending file: $file"
                )"
                continue
            elif [[ "$customer_id" != "$required_customer" ]] && [[ "$customer_id" != "special" ]] && [[ "$required_customer" != "special" ]] ; then
                # ignore constraints for special alters on either side
                # non-schema alter reqires different non-schema customer alter
                hook_error "$(
                    color_echo red "Customer specific alters are not allowed to require a different customer's alters"
                    color_echo yellow "Offending file: $file"
                )"
                continue
            fi
        done
    fi

    # check for comments on tables

    # get the list of created table names
    created_tables=`cat "$file" | grep -o -i -P "(create\\s+table(\\s+if\\s+not\\s+exists)?\\s+)\\K['\"]?\\w+" | tr -d '"' | tr -d "'" | tr -d "("`
    for table_name in $created_tables ; do
        # take off any trailing newline
        table_name=`echo "$table_name" | tr -d '\n'`

        # ensure that the table_name is correct
        if ! echo "$table_name" | grep -q -P "^tb_\\w+$" ; then
            # table name is incorrect
            hook_error "$(
                color_echo red "Found incorrect table name in file '$file'"
                color_echo yellow "Offending name: $table_name"
                echo "Hint: Tables must begin with 'tb_'."
            )"
            continue
        fi

        # check if there's a "comment on table <table_name>" statement in the file
        if ! cat "$file" | grep -q -Pi "comment\\s+on\\s+table\\s+['\"]?$table_name\\b" ; then
            # missing comment on table
            hook_error "$(
                color_echo red "Missing required 'comment on table' statement for $table_name"
                color_echo yellow "Offending file: $file"
            )"
            continue
        fi
    done

    # check for a --description: comment
    if ! cat "$file" | grep -q -P '^--description:\s' ; then
        # no description found
        hook_error "$(
            color_echo red "Alter file is missing description comment."
            color_echo yellow "Offending file: $file"
            echo "Hint: All alters must have a '--description: ' comment at the top of the alter."
        )"
        continue
    fi

    # ensure that alters do not call get_translation() (the 1 argument form)
    if cat "$file" | grep -q -P 'get_translation\(' ; then
        # there exists a line in the alter with a get_translation call
        hook_error "$(
            color_echo red "Alter file calls \`get_translation\` instead of \`get_translation_immutable\`"
            color_echo yellow "Offending file: $file"
            echo "Hint: Alters must always call \`get_translation_immutable( <col>, 'fallback' )\`"
        )"
    fi

    # ensure that all calls to get_translation_immutable have 2 arguments and 'fallback' as their locale argument
    if cat "$file" | grep -q -P $'get_translation_immutable\\([^,]+,\\s*[\'"](?!fallback)\\w+[\'"]\\s*\\)' ; then
        # there exists a line in the alter with a get_translation_immutable call where the second argument is not 'fallback'
        hook_error "$(
            color_echo red "Alter file calls \`get_translation_immutable\` without specifying the 'fallback' locale as the second argument."
            color_echo yellow "Offending file: $file"
            echo "Hint: Alters must always call \`get_translation( <col>, 'fallback' )\`"
        )"
    fi

    # no calls to `fn_label_last_transaction()` are allowed, should instead
    # be called `fn_label_transaction()` because we will be inside 1 transaction when
    # the alter is applied
    if cat "$file" | grep -q -P 'fn_label_last_transaction\(' ; then
        hook_error "$(
            color_echo red "Alter file calls \`fn_label_last_transaction()\`."
            color_echo yellow "Offending file: $file"
            echo "Hint: You should be using \`fn_label_transaction()\` because when the alter is run,"
            echo "      it will be inside of a single transaction."
        )"
    fi

done

hook_exit
