#!/bin/bash

# INPUTS
commit_message_file="$1"
commit_source="$2"
commit_message=`cat $commit_message_file`

source .git/hooks/lib.sh

exit_if_commit_hooks_should_not_run

# Enforce that commit hooks ran without --no-verify
seconds_since_hooks_ran=$(expr `date +%s` - `stat -c %Y $GIT_DIR/$_commit_hook_enforce_file 2>/dev/null` 2>/dev/null)
if [[ ! -f "$GIT_DIR/$_commit_hook_enforce_file" ]] || [[ "$seconds_since_hooks_ran" -gt 1 ]] ; then
    color_echo red "Aborting commit because this commit has not been verified!"
    color_echo yellow "Do not use --no-verify or -n in your commit flags!"
    exit 1
fi

# PROGRAM FUNCTIONS

# check if ticket matches JIRA format
declare -a ticket_formats=(
   'PROD-[0-9]+'
   'TEST-[0-9]+'
   'THDIC-[0-9]+'
   'XERP-[0-9]+'
   'SCOR-[0-9]+'
   'SS-[0-9]+'
   'DVO-[0-9]+'
)

# MAIN PROGRAM

echo "-PREPARE-COMMIT-MSG HOOKS-------------------------------------------------------------------------"

# get any pre-recorded user supplied commit message and ticket

# only run these commit hooks if the commit is a "normal" commit
should_update_commit_msg=true
case $commit_source in
    *message*)
        should_update_commit_msg=true
        echo ""

        # message pre-sent with -m "msg"
        color_echo green "Tip: Run \`git commit\` without the -m flag to create a well-formatted commit message!"

        # user supplied subject to start
        subject="$commit_message"

        # get the ticket, if it's the first word
        ticket=`echo $commit_message | awk '{print $1}'`
        matches_regex_element "$ticket" "${ticket_formats[@]}"
        if [[ $? != 0 ]] ; then
            # "ticket" doesn't match a valid format, so assume it's not a ticket
            ticket=""
        else
            # "ticket" does match a valid format, so take it off the subject
            subject=`echo $commit_message | cut -d' ' -f2-`
        fi

        # ensure that the commit message is in the imperative mood
        # warn about the commit message being in a non-imperative mood
        echo ""
        color_echo yellow "Please try to ensure that your commit messages are in the imperative tense."
        color_echo yellow "If the following sentence doesn't make sense, please amend your commit with \`g commit --amend\`."
        echo ""
        echo -e -n "    \"If applied, this commit will \033[1;32m$subject\033[0m\"\n"
        echo ""
        ;;
    *template*)
        # ignore
        should_update_commit_msg=false
        ;;
    *merge*)
        # ignore
        should_update_commit_msg=false
        ;;
    *squash*)
        # ignore
        should_update_commit_msg=false
        ;;
    *commit*)
        # ignore
        should_update_commit_msg=false
        ;;
    *)
        should_update_commit_msg=true
        echo ""

        # default to requesting new subject and ticket
        request_new_commit_msg_parts="true"

        # check to see if there is a recorded commit message
        commit_record=`grep -P "^commit_message" $GIT_DIR/$_commit_hook_enforce_file`
        if [[ -n $commit_record ]] ; then
            # retrieve the commit message subject and ticket
            subject=`echo $commit_record | grep -o -P "\|subject:.*\|ticket:" | rev | cut -c9- | rev | cut -d: -f2-`
            ticket=`echo $commit_record | grep -o -P "\|ticket:.*$" | cut -d: -f2-`

            # ask if the user would like to re-use this recorded message
            color_echo yellow "Found a previously saved commit message subject and ticket:"
            echo -e "\tsubject: $subject"

            # a blank ticket means default, but this can be confusing for the user
            # let's be explicit instead
            if [[ -z $ticket ]] ; then
                echo -e "\tticket:  [default]"
            else
                echo -e "\tticket:  $ticket"
            fi

            echo ""
            ask_with_timeout "5" "y" "Would you like to reuse these commit message parts?"

            if [[ $ANSWER == y ]] ; then
                request_new_commit_msg_parts="false"
            else
                request_new_commit_msg_parts="true"
            fi
        fi

        if [[ $request_new_commit_msg_parts == true ]] ; then
            q "Which ticket is this for? [blank to default]"
            ticket="$ANSWER"

            q "If applied, this commit will"
            subject="$ANSWER"

            while [[ -z "$subject" ]] ; do
                color_echo red "Please provide a brief commit message!"
                q "If applied, this commit will"
                subject="$ANSWER"
            done
        fi
        ;;
esac

if [[ "$should_update_commit_msg" == "false" ]] ; then
    # all done!
    exit 0
fi

# build the commit message record
record="commit_message|subject:$subject|ticket:$ticket"

# replace or add the commit message record
if grep -q -P "^commit_message" $GIT_DIR/$_commit_hook_enforce_file ; then
    export _TEMP_RECORD="$record"
    perl -p -i -e "s{^commit_message.*}{\$ENV{_TEMP_RECORD}}" $GIT_DIR/$_commit_hook_enforce_file
    unset _TEMP_RECORD
else
    echo "$record" >> $GIT_DIR/$_commit_hook_enforce_file
fi

# continue
color_echo yellow "Preparing commit message..."

# uppercase the first character of the subject
subject="${subject^}"

# if the ticket is blank, then default to trying to figure out the ticket!
if [[ -z "$ticket" ]] ; then
    # parse the current branch to figure out the ticket, version, and adjust the subject
    current_branch=`git rev-parse --abbrev-ref HEAD`
    if [[ $current_branch =~ ^bug_ ]] ; then
        # bug branch follow form bug_<version>_<ticket>
        version=`echo $current_branch | cut -f2 -d"_"`
        ticket=`echo $current_branch | cut -f3 -d"_"`
        subject="$ticket ($version) $subject"
    else
        # branch == ticket
        subject="$current_branch $subject"
    fi
else
    # ticket was provided, so just add it to the front of the subject
    subject="$ticket $subject"
fi

# body is everything past # chars of the subject
short_subject=`echo $subject | fmt -u -w 100 | head -1`
body=`echo $subject | cut -c$((${#short_subject}+1))-`
subject=`echo $subject | cut -c1-${#short_subject}`

# add ellipses if the subject continues into a body
if [[ -n "$body" ]] ; then
    subject+="..."
    body="...$body"
fi

# body should be word wrapped at 72 chars
body=`echo $body | fmt -u -w 100`

 template="# How to Write a Git Commit Message [see: https://chris.beams.io/posts/git-commit/]\n"
template+="\n"
template+="# <ticket> (<version>) Short subject\n"
template+="$subject\n"

# if there is a continued subject ("body") then add that to the template
if [[ -n "$body" ]] ; then
    template+="\n"
    template+="# Continued\n"
    template+="$body\n"
fi

template+="\n"
template+="# What does this commit change, and why?\n"
template+="#\n"
template+="#     - Change 1\n"
template+="#\n"
template+="#     - Change 2\n"
template+="#\n"
template+="#     - Change 3\n"
template+="\n"

# check to see if we had any commit hook overrides
override_count=`cat $GIT_DIR/$_commit_hook_enforce_file | grep -P '^\d.*?:.*?:.+$' | wc -l`
if [[ "$override_count" != 0 ]] ; then

    # there were overrides, so
    # get each override by line and update the commit message with format:
    #
    # Commit Hook Overrides:
    #   - <name>: <reason>

    template+="\n"
    template+="# List which commit hooks were overridden and why.\n"
    template+="Commit Hook Overrides:\n"

    while read line ; do
        commit_hook=`echo $line | cut -d: -f1`
        override=`echo $line | cut -d: -f3-`
        template+="  - $commit_hook: $override\n"
    done < <(cat $GIT_DIR/$_commit_hook_enforce_file | grep -P '^\d.*?:.*?:.+$')
fi

# add additional section
template+="\n"
template+="# List related JIRA issues, Confluence pages, or documentation below.\n"
template+="# See also: XERP-1234, DVO-321, DOC-42\n"

# if there was a previously saved formatted commit message, add that info
# to the bottom of the template, but before the default commit message section
if [[ -f "$GIT_DIR/.saved_commit_message" ]] ; then
    template+="\n\n"
    template+="# NOTE: You have a previously saved commit message that's already been formatted.\n"
    template+="#       You can view that message in $GIT_DIR/.saved_commit_message"
fi

# delete all non-comment lines from the default commit msg
sed -i '/^[^#]/d' $commit_message_file

# prepend template to the default commit msg
tmp_file="/tmp/tmp_msg.$$.txt"
echo -e "$template" | cat - $commit_message_file > $tmp_file && mv $tmp_file $commit_message_file && rm -f $tmp_file

# add vim modeline commands
echo "# vim: set ts=4:sw4:tw=80:bg=dark" >> "$commit_message_file"

# all done!
exit 0
