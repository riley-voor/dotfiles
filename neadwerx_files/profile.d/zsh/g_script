function get_git_branch() {
    branch=$(git rev-parse --abbrev-ref HEAD)
    echo "$branch"
}

function git_pull() {
    local branch="$(get_git_branch)"
    local BRIGHTRED="\033[1;31;40m"
    local NORMAL="\033[0m"

    local merge_status="$(_git_merge_status)"
    if [ -n "$merge_status" ] ; then
        echo "Skipping pull due to merge status: $merge_status"
        return
    fi

    color_echo "git fetch"
    HOME=${userdir:-$HOME} /usr/bin/git fetch

    HOME=${userdir:-$HOME} /usr/bin/git stash list | grep -q 'created by g() for pull' && {
        echo "You already have local changes stashed by this script, please"
        echo "use 'g stash drop' to remove them if no longer needed then proceed"
        echo "(did you do a 'g stash drop' after your last conflict?)"
        HOME=${userdir:-$HOME} /usr/bin/git stash list
        return
    }

    # stash changes
    color_echo "git stash save $branch --keep-index"
    HOME=${userdir:-$HOME} /usr/bin/git stash save "created by g() for pull" --keep-index

    # See if we actually stashed anything
    stashed=0
    HOME=${userdir:-$HOME} /usr/bin/git stash list | grep -q 'created by g() for pull' && {
        stashed=1
    }

    # See if we are already ahead of origin
    ahead=`HOME=${userdir:-$HOME} /usr/bin/git cherry | wc -l`
    has_conflicts="false"

    if [[ "$ahead" -gt 0 ]] ; then
        # rebase
        color_echo "git pull --rebase"
        HOME=${userdir:-$HOME} /usr/bin/git pull --rebase || {
            echo -e "$BRIGHTRED ** PULL FAILED ** $NORMAL"
            echo ""
            echo "Please resolve these conflicts using the rebase commands. See \`git st\`."
            has_conflicts="true"
        }
    else
        # merge
        color_echo "git pull"
        HOME=${userdir:-$HOME} /usr/bin/git pull || {
            echo -e "$BRIGHTRED ** PULL FAILED ** $NORMAL"
        }
    fi

    if [[ "$stashed" == 1 ]] ; then
        if [[ "$has_conflicts" == true ]] ; then
            echo ""
            echo "Remember to unstash your changes with \`g stash pop\` after resolving the conflicts."
            return
        else
            # unstash
            g stash pop
        fi
    else
        [[ "$has_conflicts" == true ]] && return
    fi

    behind_count=$(git rev-list --left-right --count origin/master...$branch 2>/dev/null | awk '{print $1}')

    if [[ ! "$branch" =~ ^v ]]; then
        if [ ${behind_count: -0} -gt 0 ] ; then
            echo -e "$BRIGHTRED""NOTE: your branch is $behind_count commits behind origin/master, please consider running 'g merge master'$NORMAL"
        fi
    fi
}

function color_echo() {
    echo -e "\033[1;33m$@\033[0m"
}

# This provides a few features:
#    1) If you are using alternate config from $userdir, it makes sure
#       your .git configuration is loaded from there
#    2) Makes sure you don't merge into any branch starting with a "v"
#    3) If you run "g clone reponame" it assumes it is a Nead Werx bitbucket repository
#       For example, "g clone xerp" is the same as: git clone git@bitbucket.org:neadwerx/xerp.git
#    4) If you run "g push" it first does a pull and then pushes only your current branch
#    5) If you run "checkout" it will do properly link your local branch to the server if it isn't
#       already defined. Then it will make sure you don't have uncommited or unpushed
#       changes in your current branch
#    6) For "commit" it will pull first, then make sure you aren't commiting to xERP master.
#
function g() {
    if [[ "$1" == "checkout" || "$1" == "co" ]] ; then
        # Checkout can be used to revert a file as well
        if [[ ! -f "$2" ]] ; then
            local git_status="`/usr/bin/git status -unormal 2>&1`"

            if [[ "$git_status" =~ Changed\ but\ not\ updated ]]; then
                echo "You have modified files and have not committed them."
                echo -n "Are you sure you want to switch? [y/N] "
                read input
                echo
                if [[ "$input" != "y" ]] ; then
                    return
                fi
            fi

            if [[ "$git_status" =~ Your\ branch\ is\ ahead\ of ]]; then
                local branch="$(get_git_branch)"
                echo "You have changes in branch $branch you have not yet pushed to the server."
                echo -n "Would you like to push them now? [Y/n] "
                read input
                echo
                if [[ "$input" != "n" ]] ; then
                    color_echo "git push origin $branch"
                    HOME=${userdir:-$HOME} /usr/bin/git push origin "$branch"
                fi
            fi

            color_echo "git fetch"
            HOME=${userdir:-$HOME} /usr/bin/git fetch

            HOME=${userdir:-$HOME} /usr/bin/git branch | grep -q "\<$2\>"

            if [[ "$?" -eq 0 ]] ; then
                # Branch already found, just switch to it
                color_echo "git checkout $2"
                HOME=${userdir:-$HOME} /usr/bin/git checkout "$2"
            else
                color_echo "git checkout -t origin/$2"
                HOME=${userdir:-$HOME} /usr/bin/git checkout -t "origin/$2"
            fi

            git_pull

            return
        fi
    elif [[ "$1" == "pull" ]] ; then
        git_pull
        return
    elif [[ "$1" == "push" && "$#" -eq 1 ]] ; then
        local branch="$(get_git_branch)"
        # For now, disable to avoid problems when pushing
        # after resolving merge conflicts
        #git_pull
        color_echo "git push origin $branch"
        HOME=${userdir:-$HOME} /usr/bin/git push origin "$branch"
        return
    elif [[ "$1" == "version" ]] ; then
        echo "0.0.1"
    elif [[ "$1" == "commit" || "$1" == "ci" ]] ; then
        git_pull

        local repository="$(git config --get remote.origin.url)"

        if [[ "$repository" == "git@bitbucket.org:neadwerx/xerp.git" ]] ; then
            local branch="$(get_git_branch)"

            if [[ "$branch" == "master" && "$USER" != "kirk" ]] ; then
                echo "You can't commit to master in this repository."
                return;
            fi
        fi
    fi

    declare -a args
    local previous=""
    for i in "$@" ; do
        if [[ "$i" == "merge" ]] ; then
            local dest_branch="$(get_git_branch)"
            if [[ "$dest_branch" =~ ^v ]]; then
                if [[ "$USER" != "kirk" && "$USER" != "jehsom" ]] ; then
                    echo "Please don't merge into v* branches"
                    return;
                fi
            fi
            args+=( "$i" "--no-ff" )
        elif [[ "$previous" == "merge" ]] ; then
            color_echo "git fetch"
            HOME=${userdir:-$HOME} /usr/bin/git fetch
            args+=( "origin/$i" )
        elif [[ "$previous" == "clone" ]] ; then
            args+=( "git@bitbucket.org:neadwerx/$i.git" )
        else
            args+=( "$i" )
        fi
        previous="$i"
    done

    # Use $userdir if set for $HOME for this command only
    color_echo "git ${args[@]}"
    HOME=${userdir:-$HOME} /usr/bin/git "${args[@]}"
}

__gitdir ()
{
    # Note: this function is duplicated in git-completion.bash
    # When updating it, make sure you update the other one to match.
    if [[ -z "${1-}" ]]; then
        if [[ -n "${__git_dir-}" ]]; then
            echo "$__git_dir"
        elif [[ -n "${GIT_DIR-}" ]]; then
            test -d "${GIT_DIR-}" || return 1
            echo "$GIT_DIR"
        elif [[ -d .git ]]; then
            echo .git
        else
            git rev-parse --git-dir 2>/dev/null
        fi
    elif [[ -d "$1/.git" ]]; then
        echo "$1/.git"
    else
        echo "$1"
    fi
}

function _git_merge_status() {
    local g="$(__gitdir)"
    r=""

    if [ -n "$g" ]; then
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="REBASE-i"
        elif [ -d "$g/rebase-merge" ]; then
            r="REBASE-m"
        else
            if [ -d "$g/rebase-apply" ]; then
                if [ -f "$g/rebase-apply/rebasing" ]; then
                    r="REBASE"
                elif [ -f "$g/rebase-apply/applying" ]; then
                    r="AM"
                else
                    r="AM/REBASE"
                fi
            elif [ -f "$g/MERGE_HEAD" ]; then
                r="MERGING"
            elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
                r="CHERRY-PICKING"
            elif [ -f "$g/BISECT_LOG" ]; then
                r="BISECTING"
            fi
        fi
    fi
    echo "$r"
}

function _git_prompt() {
    local git_status="`/usr/bin/git status -unormal 2>&1`"
    if ! [[ "$git_status" =~ Not\ a\ git\ repo ]]; then
        if [[ "$git_status" =~ nothing\ to\ commit ]]; then
            # green: nothing to commit
            local ansi=42
        elif [[ "$git_status" =~ nothing\ added\ to\ commit\ but\ untracked\ files\ present ]]; then
            # yellow: un-added files
            local ansi=43
        else
            # red: modified files
            local ansi=41
        fi
        if [[ "$git_status" =~ On\ branch\ ([^[:space:]]+) ]]; then
            local branch=${match}
            if [[ "$branch" = "master" ]]; then
                branch=" "
            fi

            if [[ "$git_status" =~ Your\ branch\ is\ ahead\ of ]]; then
                # Two red !! marks if you haven't pushed your local changes
                echo -n $'%{\e[0;37;41;1m%}!!%{\e[0m%} '
            fi
        else
            # Detached HEAD.  (branch=HEAD is a faster alternative.)
            branch="(`/usr/bin/git describe --all --contains --abbrev=4 HEAD 2> /dev/null ||
                echo HEAD`)"
        fi
        echo -n $'%{\e[0;37;'"$ansi"';1m%}'"$branch"'%{\e[0m%} '
    fi
}

PROMPT_ORIG=""

_promptcmd() {
    if [ -z $PROMPT_ORIG ] ; then
        PROMPT_ORIG="$PROMPT"
    fi

    local parse_git_prompt='$(_git_prompt)'
    setopt promptsubst
    PROMPT="${parse_git_prompt}$PROMPT_ORIG"
}

precmd_functions=(_promptcmd)
